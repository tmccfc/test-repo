name: "Auto-merge when checklist satisfied"

on:
  pull_request:
    types: [opened, edited, reopened, synchronize, labeled, unlabeled]

permissions:
  contents: read
  pull-requests: write    # needed to merge
  checks: read
  statuses: read

jobs:
  automerge:
    runs-on: ubuntu-latest
    steps:
      - name: Auto-merge if checklist satisfied
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info("No pull_request object in payload — exiting.");
              return;
            }
            const prNumber = pr.number;
            const prBody = pr.body || "";
            // Configuration: change REQUIRED_CHECKBOX to the exact label you want, or "any".
            const REQUIRED_CHECKBOX = process.env.REQUIRED_CHECKBOX || "any";
            const MERGE_METHOD = process.env.MERGE_METHOD || "squash"; // merge | squash | rebase

            function escapeRegExp(string) {
              return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            // Check checklist condition
            let checklistOk = false;
            if (REQUIRED_CHECKBOX.toLowerCase() === "any") {
              checklistOk = /\- \[[xX]\]\s+/.test(prBody);
            } else {
              const pattern = new RegExp(`- \\[[xX]\\]\\s*${escapeRegExp(REQUIRED_CHECKBOX)}`);
              checklistOk = pattern.test(prBody);
            }

            if (!checklistOk) {
              core.info(`Checklist requirement not met (REQUIRED_CHECKBOX="${REQUIRED_CHECKBOX}"). Exiting without merge.`);
              return;
            }
            core.info("Checklist requirement satisfied — checking status/check runs and mergeability...");

            // Helper: wait n ms
            const wait = ms => new Promise(resolve => setTimeout(resolve, ms));

            // Wait/retry for mergeable to be computed (mergeable can be null)
            let prDetail = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            let retries = 0;
            while (prDetail.data.mergeable === null && retries < 8) {
              core.info("PR mergeable is null — waiting 2s and retrying...");
              await wait(2000);
              prDetail = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              retries++;
            }

            // if GitHub says not mergeable (e.g. conflicts), abort
            if (prDetail.data.mergeable === false) {
              core.info(`PR is not mergeable (mergeable=false). Merge aborted.`);
              return;
            }

            // Check GitHub status (legacy combined status) and check-runs
            const commitSha = pr.head.sha;

            // Check combined status
            const combined = await github.rest.repos.getCombinedStatusForRef({
              owner, repo, ref: commitSha
            });

            core.info(`Combined status for ${commitSha} -> ${combined.data.state}`);

            // Check check-runs for the commit
            const checks = await github.rest.checks.listForRef({
              owner, repo, ref: commitSha
            });

            // Decide if checks are passing:
            // Combined state must be "success" OR "neutral" (allow neutral), and no check-runs have failure/neutral? We'll require no 'failure'/'cancelled'/'timed_out'.
            const badRun = checks.data.check_runs.find(cr => ["failure","cancelled","timed_out"].includes(cr.conclusion));
            if (combined.data.state !== "success" && combined.data.state !== "neutral") {
              core.info("Combined status is not success/neutral — not ready to auto-merge.");
              return;
            }
            if (badRun) {
              core.info(`Found bad check-run conclusion: ${badRun.name} -> ${badRun.conclusion}. Not merging.`);
              return;
            }

            // Optional: require PR to be up-to-date with base (no required branch-updater handling here).
            // Attempt to merge
            try {
              core.info(`Attempting to merge PR #${prNumber} using method "${MERGE_METHOD}"...`);
              const mergeResp = await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: prNumber,
                commit_title: `Auto-merged PR #${prNumber} — checklist satisfied`,
                merge_method: MERGE_METHOD
              });

              if (mergeResp.status === 200) {
                core.info(`Merge successful: ${JSON.stringify(mergeResp.data)}`);
              } else {
                core.info(`Merge response status: ${mergeResp.status}. Response: ${JSON.stringify(mergeResp.data)}`);
              }
            } catch (err) {
              core.info(`Merge failed: ${err.message}`);
              // If merge failed due to branch protection (e.g. requires reviews, or auto-merge disabled),
              // surface a friendly message in the action logs.
              core.setFailed(`Auto-merge attempt failed: ${err.message}`);
            }
        env:
          REQUIRED_CHECKBOX: "Security review completed"  # <--- change to exact label, or set to "any"
          MERGE_METHOD: "squash"                          # <--- "merge" | "squash" | "rebase"
